// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `pipeline.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.PipelineStep)
pub struct PipelineStep {
    // message fields
    ///  Unique ID for the step
    // @@protoc_insertion_point(field:protos.PipelineStep.id)
    pub id: ::std::string::String,
    ///  Friendly name for the step
    // @@protoc_insertion_point(field:protos.PipelineStep.name)
    pub name: ::std::string::String,
    ///  Input bytes for next step (probably PipelineStepResponse.output from previous step)
    // @@protoc_insertion_point(field:protos.PipelineStep.input)
    pub input: ::std::vec::Vec<u8>,
    ///  WASM module ID
    // @@protoc_insertion_point(field:protos.PipelineStep.wasm_id)
    pub wasm_id: ::std::string::String,
    ///  WASM module bytes
    // @@protoc_insertion_point(field:protos.PipelineStep.wasm_bytes)
    pub wasm_bytes: ::std::string::String,
    ///  WASM function name to execute
    // @@protoc_insertion_point(field:protos.PipelineStep.wasm_function)
    pub wasm_function: ::std::string::String,
    ///  Conditions that SDK should check before executing next step
    // @@protoc_insertion_point(field:protos.PipelineStep.conditions)
    pub conditions: ::std::vec::Vec<::protobuf::EnumOrUnknown<Condition>>,
    // message oneof groups
    pub step: ::std::option::Option<pipeline_step::Step>,
    // special fields
    // @@protoc_insertion_point(special_field:protos.PipelineStep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PipelineStep {
    fn default() -> &'a PipelineStep {
        <PipelineStep as ::protobuf::Message>::default_instance()
    }
}

impl PipelineStep {
    pub fn new() -> PipelineStep {
        ::std::default::Default::default()
    }

    // .protos.steps.DetectiveStep detective = 1000;

    pub fn detective(&self) -> &super::detective::DetectiveStep {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Detective(ref v)) => v,
            _ => <super::detective::DetectiveStep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_detective(&mut self) {
        self.step = ::std::option::Option::None;
    }

    pub fn has_detective(&self) -> bool {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Detective(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_detective(&mut self, v: super::detective::DetectiveStep) {
        self.step = ::std::option::Option::Some(pipeline_step::Step::Detective(v))
    }

    // Mutable pointer to the field.
    pub fn mut_detective(&mut self) -> &mut super::detective::DetectiveStep {
        if let ::std::option::Option::Some(pipeline_step::Step::Detective(_)) = self.step {
        } else {
            self.step = ::std::option::Option::Some(pipeline_step::Step::Detective(super::detective::DetectiveStep::new()));
        }
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Detective(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_detective(&mut self) -> super::detective::DetectiveStep {
        if self.has_detective() {
            match self.step.take() {
                ::std::option::Option::Some(pipeline_step::Step::Detective(v)) => v,
                _ => panic!(),
            }
        } else {
            super::detective::DetectiveStep::new()
        }
    }

    // .protos.steps.TransformStep transform = 1001;

    pub fn transform(&self) -> &super::transform::TransformStep {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Transform(ref v)) => v,
            _ => <super::transform::TransformStep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transform(&mut self) {
        self.step = ::std::option::Option::None;
    }

    pub fn has_transform(&self) -> bool {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Transform(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transform(&mut self, v: super::transform::TransformStep) {
        self.step = ::std::option::Option::Some(pipeline_step::Step::Transform(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transform(&mut self) -> &mut super::transform::TransformStep {
        if let ::std::option::Option::Some(pipeline_step::Step::Transform(_)) = self.step {
        } else {
            self.step = ::std::option::Option::Some(pipeline_step::Step::Transform(super::transform::TransformStep::new()));
        }
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Transform(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transform(&mut self) -> super::transform::TransformStep {
        if self.has_transform() {
            match self.step.take() {
                ::std::option::Option::Some(pipeline_step::Step::Transform(v)) => v,
                _ => panic!(),
            }
        } else {
            super::transform::TransformStep::new()
        }
    }

    // .protos.steps.EncodeStep encode = 1002;

    pub fn encode(&self) -> &super::encode::EncodeStep {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Encode(ref v)) => v,
            _ => <super::encode::EncodeStep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_encode(&mut self) {
        self.step = ::std::option::Option::None;
    }

    pub fn has_encode(&self) -> bool {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Encode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_encode(&mut self, v: super::encode::EncodeStep) {
        self.step = ::std::option::Option::Some(pipeline_step::Step::Encode(v))
    }

    // Mutable pointer to the field.
    pub fn mut_encode(&mut self) -> &mut super::encode::EncodeStep {
        if let ::std::option::Option::Some(pipeline_step::Step::Encode(_)) = self.step {
        } else {
            self.step = ::std::option::Option::Some(pipeline_step::Step::Encode(super::encode::EncodeStep::new()));
        }
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Encode(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_encode(&mut self) -> super::encode::EncodeStep {
        if self.has_encode() {
            match self.step.take() {
                ::std::option::Option::Some(pipeline_step::Step::Encode(v)) => v,
                _ => panic!(),
            }
        } else {
            super::encode::EncodeStep::new()
        }
    }

    // .protos.steps.DecodeStep decode = 1003;

    pub fn decode(&self) -> &super::decode::DecodeStep {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Decode(ref v)) => v,
            _ => <super::decode::DecodeStep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_decode(&mut self) {
        self.step = ::std::option::Option::None;
    }

    pub fn has_decode(&self) -> bool {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Decode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_decode(&mut self, v: super::decode::DecodeStep) {
        self.step = ::std::option::Option::Some(pipeline_step::Step::Decode(v))
    }

    // Mutable pointer to the field.
    pub fn mut_decode(&mut self) -> &mut super::decode::DecodeStep {
        if let ::std::option::Option::Some(pipeline_step::Step::Decode(_)) = self.step {
        } else {
            self.step = ::std::option::Option::Some(pipeline_step::Step::Decode(super::decode::DecodeStep::new()));
        }
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Decode(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_decode(&mut self) -> super::decode::DecodeStep {
        if self.has_decode() {
            match self.step.take() {
                ::std::option::Option::Some(pipeline_step::Step::Decode(v)) => v,
                _ => panic!(),
            }
        } else {
            super::decode::DecodeStep::new()
        }
    }

    // .protos.steps.CustomStep custom = 1004;

    pub fn custom(&self) -> &super::custom::CustomStep {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Custom(ref v)) => v,
            _ => <super::custom::CustomStep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_custom(&mut self) {
        self.step = ::std::option::Option::None;
    }

    pub fn has_custom(&self) -> bool {
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Custom(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_custom(&mut self, v: super::custom::CustomStep) {
        self.step = ::std::option::Option::Some(pipeline_step::Step::Custom(v))
    }

    // Mutable pointer to the field.
    pub fn mut_custom(&mut self) -> &mut super::custom::CustomStep {
        if let ::std::option::Option::Some(pipeline_step::Step::Custom(_)) = self.step {
        } else {
            self.step = ::std::option::Option::Some(pipeline_step::Step::Custom(super::custom::CustomStep::new()));
        }
        match self.step {
            ::std::option::Option::Some(pipeline_step::Step::Custom(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_custom(&mut self) -> super::custom::CustomStep {
        if self.has_custom() {
            match self.step.take() {
                ::std::option::Option::Some(pipeline_step::Step::Custom(v)) => v,
                _ => panic!(),
            }
        } else {
            super::custom::CustomStep::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PipelineStep| { &m.id },
            |m: &mut PipelineStep| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &PipelineStep| { &m.name },
            |m: &mut PipelineStep| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &PipelineStep| { &m.input },
            |m: &mut PipelineStep| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wasm_id",
            |m: &PipelineStep| { &m.wasm_id },
            |m: &mut PipelineStep| { &mut m.wasm_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wasm_bytes",
            |m: &PipelineStep| { &m.wasm_bytes },
            |m: &mut PipelineStep| { &mut m.wasm_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wasm_function",
            |m: &PipelineStep| { &m.wasm_function },
            |m: &mut PipelineStep| { &mut m.wasm_function },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &PipelineStep| { &m.conditions },
            |m: &mut PipelineStep| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::detective::DetectiveStep>(
            "detective",
            PipelineStep::has_detective,
            PipelineStep::detective,
            PipelineStep::mut_detective,
            PipelineStep::set_detective,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::transform::TransformStep>(
            "transform",
            PipelineStep::has_transform,
            PipelineStep::transform,
            PipelineStep::mut_transform,
            PipelineStep::set_transform,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::encode::EncodeStep>(
            "encode",
            PipelineStep::has_encode,
            PipelineStep::encode,
            PipelineStep::mut_encode,
            PipelineStep::set_encode,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::decode::DecodeStep>(
            "decode",
            PipelineStep::has_decode,
            PipelineStep::decode,
            PipelineStep::mut_decode,
            PipelineStep::set_decode,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::custom::CustomStep>(
            "custom",
            PipelineStep::has_custom,
            PipelineStep::custom,
            PipelineStep::mut_custom,
            PipelineStep::set_custom,
        ));
        oneofs.push(pipeline_step::Step::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PipelineStep>(
            "PipelineStep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PipelineStep {
    const NAME: &'static str = "PipelineStep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.input = is.read_bytes()?;
                },
                34 => {
                    self.wasm_id = is.read_string()?;
                },
                42 => {
                    self.wasm_bytes = is.read_string()?;
                },
                50 => {
                    self.wasm_function = is.read_string()?;
                },
                56 => {
                    self.conditions.push(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.conditions)?
                },
                8002 => {
                    self.step = ::std::option::Option::Some(pipeline_step::Step::Detective(is.read_message()?));
                },
                8010 => {
                    self.step = ::std::option::Option::Some(pipeline_step::Step::Transform(is.read_message()?));
                },
                8018 => {
                    self.step = ::std::option::Option::Some(pipeline_step::Step::Encode(is.read_message()?));
                },
                8026 => {
                    self.step = ::std::option::Option::Some(pipeline_step::Step::Decode(is.read_message()?));
                },
                8034 => {
                    self.step = ::std::option::Option::Some(pipeline_step::Step::Custom(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.input);
        }
        if !self.wasm_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.wasm_id);
        }
        if !self.wasm_bytes.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.wasm_bytes);
        }
        if !self.wasm_function.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.wasm_function);
        }
        for value in &self.conditions {
            my_size += ::protobuf::rt::int32_size(7, value.value());
        };
        if let ::std::option::Option::Some(ref v) = self.step {
            match v {
                &pipeline_step::Step::Detective(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &pipeline_step::Step::Transform(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &pipeline_step::Step::Encode(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &pipeline_step::Step::Decode(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &pipeline_step::Step::Custom(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.input.is_empty() {
            os.write_bytes(3, &self.input)?;
        }
        if !self.wasm_id.is_empty() {
            os.write_string(4, &self.wasm_id)?;
        }
        if !self.wasm_bytes.is_empty() {
            os.write_string(5, &self.wasm_bytes)?;
        }
        if !self.wasm_function.is_empty() {
            os.write_string(6, &self.wasm_function)?;
        }
        for v in &self.conditions {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let ::std::option::Option::Some(ref v) = self.step {
            match v {
                &pipeline_step::Step::Detective(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1000, v, os)?;
                },
                &pipeline_step::Step::Transform(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1001, v, os)?;
                },
                &pipeline_step::Step::Encode(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1002, v, os)?;
                },
                &pipeline_step::Step::Decode(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1003, v, os)?;
                },
                &pipeline_step::Step::Custom(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1004, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PipelineStep {
        PipelineStep::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.input.clear();
        self.wasm_id.clear();
        self.wasm_bytes.clear();
        self.wasm_function.clear();
        self.conditions.clear();
        self.step = ::std::option::Option::None;
        self.step = ::std::option::Option::None;
        self.step = ::std::option::Option::None;
        self.step = ::std::option::Option::None;
        self.step = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PipelineStep {
        static instance: PipelineStep = PipelineStep {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            input: ::std::vec::Vec::new(),
            wasm_id: ::std::string::String::new(),
            wasm_bytes: ::std::string::String::new(),
            wasm_function: ::std::string::String::new(),
            conditions: ::std::vec::Vec::new(),
            step: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PipelineStep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PipelineStep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PipelineStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PipelineStep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PipelineStep`
pub mod pipeline_step {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:protos.PipelineStep.step)
    pub enum Step {
        // @@protoc_insertion_point(oneof_field:protos.PipelineStep.detective)
        Detective(super::super::detective::DetectiveStep),
        // @@protoc_insertion_point(oneof_field:protos.PipelineStep.transform)
        Transform(super::super::transform::TransformStep),
        // @@protoc_insertion_point(oneof_field:protos.PipelineStep.encode)
        Encode(super::super::encode::EncodeStep),
        // @@protoc_insertion_point(oneof_field:protos.PipelineStep.decode)
        Decode(super::super::decode::DecodeStep),
        // @@protoc_insertion_point(oneof_field:protos.PipelineStep.custom)
        Custom(super::super::custom::CustomStep),
    }

    impl ::protobuf::Oneof for Step {
    }

    impl ::protobuf::OneofFull for Step {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PipelineStep as ::protobuf::MessageFull>::descriptor().oneof_by_name("step").unwrap()).clone()
        }
    }

    impl Step {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Step>("step")
        }
    }
}

///  All WASM funcs return this upon completion. All WASM funcs MUST include `output`
///  (even if they do not modify the input).
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.PipelineStepResponse)
pub struct PipelineStepResponse {
    // message fields
    // @@protoc_insertion_point(field:protos.PipelineStepResponse.output)
    pub output: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protos.PipelineStepResponse.status)
    pub status: ::protobuf::EnumOrUnknown<PipelineStepStatus>,
    // @@protoc_insertion_point(field:protos.PipelineStepResponse.status_message)
    pub status_message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.PipelineStepResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PipelineStepResponse {
    fn default() -> &'a PipelineStepResponse {
        <PipelineStepResponse as ::protobuf::Message>::default_instance()
    }
}

impl PipelineStepResponse {
    pub fn new() -> PipelineStepResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output",
            |m: &PipelineStepResponse| { &m.output },
            |m: &mut PipelineStepResponse| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &PipelineStepResponse| { &m.status },
            |m: &mut PipelineStepResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_message",
            |m: &PipelineStepResponse| { &m.status_message },
            |m: &mut PipelineStepResponse| { &mut m.status_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PipelineStepResponse>(
            "PipelineStepResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PipelineStepResponse {
    const NAME: &'static str = "PipelineStepResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.output = is.read_bytes()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.status_message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.output);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(PipelineStepStatus::PIPELINE_STEP_STATUS_UNSET) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if !self.status_message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.status_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.output.is_empty() {
            os.write_bytes(1, &self.output)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(PipelineStepStatus::PIPELINE_STEP_STATUS_UNSET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.status_message.is_empty() {
            os.write_string(3, &self.status_message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PipelineStepResponse {
        PipelineStepResponse::new()
    }

    fn clear(&mut self) {
        self.output.clear();
        self.status = ::protobuf::EnumOrUnknown::new(PipelineStepStatus::PIPELINE_STEP_STATUS_UNSET);
        self.status_message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PipelineStepResponse {
        static instance: PipelineStepResponse = PipelineStepResponse {
            output: ::std::vec::Vec::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            status_message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PipelineStepResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PipelineStepResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PipelineStepResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PipelineStepResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetPipelineRequest)
pub struct GetPipelineRequest {
    // message fields
    // @@protoc_insertion_point(field:protos.GetPipelineRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetPipelineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPipelineRequest {
    fn default() -> &'a GetPipelineRequest {
        <GetPipelineRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPipelineRequest {
    pub fn new() -> GetPipelineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetPipelineRequest| { &m.id },
            |m: &mut GetPipelineRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPipelineRequest>(
            "GetPipelineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPipelineRequest {
    const NAME: &'static str = "GetPipelineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPipelineRequest {
        GetPipelineRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPipelineRequest {
        static instance: GetPipelineRequest = GetPipelineRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPipelineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPipelineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPipelineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPipelineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetPipelineResponse)
pub struct GetPipelineResponse {
    // message fields
    // @@protoc_insertion_point(field:protos.GetPipelineResponse.pipeline)
    pub pipeline: ::protobuf::MessageField<SetPipelineRequest>,
    // @@protoc_insertion_point(field:protos.GetPipelineResponse.status)
    pub status: ::protobuf::EnumOrUnknown<super::common::ResponseStatus>,
    // @@protoc_insertion_point(field:protos.GetPipelineResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetPipelineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPipelineResponse {
    fn default() -> &'a GetPipelineResponse {
        <GetPipelineResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPipelineResponse {
    pub fn new() -> GetPipelineResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SetPipelineRequest>(
            "pipeline",
            |m: &GetPipelineResponse| { &m.pipeline },
            |m: &mut GetPipelineResponse| { &mut m.pipeline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &GetPipelineResponse| { &m.status },
            |m: &mut GetPipelineResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &GetPipelineResponse| { &m.message },
            |m: &mut GetPipelineResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPipelineResponse>(
            "GetPipelineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPipelineResponse {
    const NAME: &'static str = "GetPipelineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pipeline)?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pipeline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pipeline.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPipelineResponse {
        GetPipelineResponse::new()
    }

    fn clear(&mut self) {
        self.pipeline.clear();
        self.status = ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET);
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPipelineResponse {
        static instance: GetPipelineResponse = GetPipelineResponse {
            pipeline: ::protobuf::MessageField::none(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPipelineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPipelineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPipelineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPipelineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetAllPipelinesRequest)
pub struct GetAllPipelinesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetAllPipelinesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAllPipelinesRequest {
    fn default() -> &'a GetAllPipelinesRequest {
        <GetAllPipelinesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAllPipelinesRequest {
    pub fn new() -> GetAllPipelinesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllPipelinesRequest>(
            "GetAllPipelinesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAllPipelinesRequest {
    const NAME: &'static str = "GetAllPipelinesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAllPipelinesRequest {
        GetAllPipelinesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAllPipelinesRequest {
        static instance: GetAllPipelinesRequest = GetAllPipelinesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAllPipelinesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAllPipelinesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAllPipelinesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllPipelinesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetAllPipelinesResponse)
pub struct GetAllPipelinesResponse {
    // message fields
    // @@protoc_insertion_point(field:protos.GetAllPipelinesResponse.pipelines)
    pub pipelines: ::std::vec::Vec<SetPipelineRequest>,
    // @@protoc_insertion_point(field:protos.GetAllPipelinesResponse.status)
    pub status: ::protobuf::EnumOrUnknown<super::common::ResponseStatus>,
    // @@protoc_insertion_point(field:protos.GetAllPipelinesResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetAllPipelinesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAllPipelinesResponse {
    fn default() -> &'a GetAllPipelinesResponse {
        <GetAllPipelinesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAllPipelinesResponse {
    pub fn new() -> GetAllPipelinesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pipelines",
            |m: &GetAllPipelinesResponse| { &m.pipelines },
            |m: &mut GetAllPipelinesResponse| { &mut m.pipelines },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &GetAllPipelinesResponse| { &m.status },
            |m: &mut GetAllPipelinesResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &GetAllPipelinesResponse| { &m.message },
            |m: &mut GetAllPipelinesResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllPipelinesResponse>(
            "GetAllPipelinesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAllPipelinesResponse {
    const NAME: &'static str = "GetAllPipelinesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pipelines.push(is.read_message()?);
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pipelines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pipelines {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAllPipelinesResponse {
        GetAllPipelinesResponse::new()
    }

    fn clear(&mut self) {
        self.pipelines.clear();
        self.status = ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET);
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAllPipelinesResponse {
        static instance: GetAllPipelinesResponse = GetAllPipelinesResponse {
            pipelines: ::std::vec::Vec::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAllPipelinesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAllPipelinesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAllPipelinesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllPipelinesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Used for both Add and Update
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.SetPipelineRequest)
pub struct SetPipelineRequest {
    // message fields
    ///  Unique ID for the pipeline
    // @@protoc_insertion_point(field:protos.SetPipelineRequest.id)
    pub id: ::std::string::String,
    ///  Friendly name for the pipeline
    // @@protoc_insertion_point(field:protos.SetPipelineRequest.name)
    pub name: ::std::string::String,
    ///  One or more steps to execute
    // @@protoc_insertion_point(field:protos.SetPipelineRequest.steps)
    pub steps: ::std::vec::Vec<PipelineStep>,
    // special fields
    // @@protoc_insertion_point(special_field:protos.SetPipelineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetPipelineRequest {
    fn default() -> &'a SetPipelineRequest {
        <SetPipelineRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPipelineRequest {
    pub fn new() -> SetPipelineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SetPipelineRequest| { &m.id },
            |m: &mut SetPipelineRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SetPipelineRequest| { &m.name },
            |m: &mut SetPipelineRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &SetPipelineRequest| { &m.steps },
            |m: &mut SetPipelineRequest| { &mut m.steps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPipelineRequest>(
            "SetPipelineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetPipelineRequest {
    const NAME: &'static str = "SetPipelineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.steps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetPipelineRequest {
        SetPipelineRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.steps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetPipelineRequest {
        static instance: SetPipelineRequest = SetPipelineRequest {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            steps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetPipelineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetPipelineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetPipelineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPipelineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.SetPipelineResponse)
pub struct SetPipelineResponse {
    // message fields
    ///  Unique ID for the pipeline
    // @@protoc_insertion_point(field:protos.SetPipelineResponse.id)
    pub id: ::std::string::String,
    ///  Response status code; use for identifying request success or failure
    // @@protoc_insertion_point(field:protos.SetPipelineResponse.status)
    pub status: ::protobuf::EnumOrUnknown<super::common::ResponseStatus>,
    ///  Additional information regarding response status
    // @@protoc_insertion_point(field:protos.SetPipelineResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.SetPipelineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetPipelineResponse {
    fn default() -> &'a SetPipelineResponse {
        <SetPipelineResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetPipelineResponse {
    pub fn new() -> SetPipelineResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SetPipelineResponse| { &m.id },
            |m: &mut SetPipelineResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &SetPipelineResponse| { &m.status },
            |m: &mut SetPipelineResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &SetPipelineResponse| { &m.message },
            |m: &mut SetPipelineResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPipelineResponse>(
            "SetPipelineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetPipelineResponse {
    const NAME: &'static str = "SetPipelineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetPipelineResponse {
        SetPipelineResponse::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.status = ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET);
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetPipelineResponse {
        static instance: SetPipelineResponse = SetPipelineResponse {
            id: ::std::string::String::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetPipelineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetPipelineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetPipelineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPipelineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.DeletePipelineRequest)
pub struct DeletePipelineRequest {
    // message fields
    ///  Unique ID for the pipeline
    // @@protoc_insertion_point(field:protos.DeletePipelineRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.DeletePipelineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeletePipelineRequest {
    fn default() -> &'a DeletePipelineRequest {
        <DeletePipelineRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePipelineRequest {
    pub fn new() -> DeletePipelineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeletePipelineRequest| { &m.id },
            |m: &mut DeletePipelineRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeletePipelineRequest>(
            "DeletePipelineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeletePipelineRequest {
    const NAME: &'static str = "DeletePipelineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeletePipelineRequest {
        DeletePipelineRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeletePipelineRequest {
        static instance: DeletePipelineRequest = DeletePipelineRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeletePipelineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeletePipelineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeletePipelineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePipelineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.DeletePipelineResponse)
pub struct DeletePipelineResponse {
    // message fields
    // @@protoc_insertion_point(field:protos.DeletePipelineResponse.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:protos.DeletePipelineResponse.status)
    pub status: ::protobuf::EnumOrUnknown<super::common::ResponseStatus>,
    // @@protoc_insertion_point(field:protos.DeletePipelineResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.DeletePipelineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeletePipelineResponse {
    fn default() -> &'a DeletePipelineResponse {
        <DeletePipelineResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeletePipelineResponse {
    pub fn new() -> DeletePipelineResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeletePipelineResponse| { &m.id },
            |m: &mut DeletePipelineResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &DeletePipelineResponse| { &m.status },
            |m: &mut DeletePipelineResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &DeletePipelineResponse| { &m.message },
            |m: &mut DeletePipelineResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeletePipelineResponse>(
            "DeletePipelineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeletePipelineResponse {
    const NAME: &'static str = "DeletePipelineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeletePipelineResponse {
        DeletePipelineResponse::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.status = ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET);
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeletePipelineResponse {
        static instance: DeletePipelineResponse = DeletePipelineResponse {
            id: ::std::string::String::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeletePipelineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeletePipelineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeletePipelineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePipelineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.PausePipelineRequest)
pub struct PausePipelineRequest {
    // message fields
    ///  Unique ID for the pipeline
    // @@protoc_insertion_point(field:protos.PausePipelineRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.PausePipelineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PausePipelineRequest {
    fn default() -> &'a PausePipelineRequest {
        <PausePipelineRequest as ::protobuf::Message>::default_instance()
    }
}

impl PausePipelineRequest {
    pub fn new() -> PausePipelineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PausePipelineRequest| { &m.id },
            |m: &mut PausePipelineRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PausePipelineRequest>(
            "PausePipelineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PausePipelineRequest {
    const NAME: &'static str = "PausePipelineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PausePipelineRequest {
        PausePipelineRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PausePipelineRequest {
        static instance: PausePipelineRequest = PausePipelineRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PausePipelineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PausePipelineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PausePipelineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PausePipelineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.PausePipelineResponse)
pub struct PausePipelineResponse {
    // message fields
    // @@protoc_insertion_point(field:protos.PausePipelineResponse.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:protos.PausePipelineResponse.status)
    pub status: ::protobuf::EnumOrUnknown<super::common::ResponseStatus>,
    // @@protoc_insertion_point(field:protos.PausePipelineResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.PausePipelineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PausePipelineResponse {
    fn default() -> &'a PausePipelineResponse {
        <PausePipelineResponse as ::protobuf::Message>::default_instance()
    }
}

impl PausePipelineResponse {
    pub fn new() -> PausePipelineResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PausePipelineResponse| { &m.id },
            |m: &mut PausePipelineResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &PausePipelineResponse| { &m.status },
            |m: &mut PausePipelineResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PausePipelineResponse| { &m.message },
            |m: &mut PausePipelineResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PausePipelineResponse>(
            "PausePipelineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PausePipelineResponse {
    const NAME: &'static str = "PausePipelineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PausePipelineResponse {
        PausePipelineResponse::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.status = ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET);
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PausePipelineResponse {
        static instance: PausePipelineResponse = PausePipelineResponse {
            id: ::std::string::String::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PausePipelineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PausePipelineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PausePipelineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PausePipelineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.UnpausePipelineRequest)
pub struct UnpausePipelineRequest {
    // message fields
    ///  Unique ID for the pipeline
    // @@protoc_insertion_point(field:protos.UnpausePipelineRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.UnpausePipelineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnpausePipelineRequest {
    fn default() -> &'a UnpausePipelineRequest {
        <UnpausePipelineRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnpausePipelineRequest {
    pub fn new() -> UnpausePipelineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UnpausePipelineRequest| { &m.id },
            |m: &mut UnpausePipelineRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnpausePipelineRequest>(
            "UnpausePipelineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnpausePipelineRequest {
    const NAME: &'static str = "UnpausePipelineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnpausePipelineRequest {
        UnpausePipelineRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnpausePipelineRequest {
        static instance: UnpausePipelineRequest = UnpausePipelineRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnpausePipelineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnpausePipelineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnpausePipelineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnpausePipelineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.UnpausePipelineResponse)
pub struct UnpausePipelineResponse {
    // message fields
    // @@protoc_insertion_point(field:protos.UnpausePipelineResponse.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:protos.UnpausePipelineResponse.status)
    pub status: ::protobuf::EnumOrUnknown<super::common::ResponseStatus>,
    // @@protoc_insertion_point(field:protos.UnpausePipelineResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.UnpausePipelineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnpausePipelineResponse {
    fn default() -> &'a UnpausePipelineResponse {
        <UnpausePipelineResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnpausePipelineResponse {
    pub fn new() -> UnpausePipelineResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UnpausePipelineResponse| { &m.id },
            |m: &mut UnpausePipelineResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &UnpausePipelineResponse| { &m.status },
            |m: &mut UnpausePipelineResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &UnpausePipelineResponse| { &m.message },
            |m: &mut UnpausePipelineResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnpausePipelineResponse>(
            "UnpausePipelineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnpausePipelineResponse {
    const NAME: &'static str = "UnpausePipelineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnpausePipelineResponse {
        UnpausePipelineResponse::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.status = ::protobuf::EnumOrUnknown::new(super::common::ResponseStatus::RESPONSE_STATUS_UNSET);
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnpausePipelineResponse {
        static instance: UnpausePipelineResponse = UnpausePipelineResponse {
            id: ::std::string::String::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnpausePipelineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnpausePipelineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnpausePipelineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnpausePipelineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Each pipeline step includes this in the response; SDK is responsible for
///  interpreting the response status and apply it to the step condition.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:protos.PipelineStepStatus)
pub enum PipelineStepStatus {
    // @@protoc_insertion_point(enum_value:protos.PipelineStepStatus.PIPELINE_STEP_STATUS_UNSET)
    PIPELINE_STEP_STATUS_UNSET = 0,
    // @@protoc_insertion_point(enum_value:protos.PipelineStepStatus.PIPELINE_STEP_STATUS_SUCCESS)
    PIPELINE_STEP_STATUS_SUCCESS = 1,
    // @@protoc_insertion_point(enum_value:protos.PipelineStepStatus.PIPELINE_STEP_STATUS_FAILURE)
    PIPELINE_STEP_STATUS_FAILURE = 2,
    // @@protoc_insertion_point(enum_value:protos.PipelineStepStatus.PIPELINE_STEP_STATUS_ERROR)
    PIPELINE_STEP_STATUS_ERROR = 3,
}

impl ::protobuf::Enum for PipelineStepStatus {
    const NAME: &'static str = "PipelineStepStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PipelineStepStatus> {
        match value {
            0 => ::std::option::Option::Some(PipelineStepStatus::PIPELINE_STEP_STATUS_UNSET),
            1 => ::std::option::Option::Some(PipelineStepStatus::PIPELINE_STEP_STATUS_SUCCESS),
            2 => ::std::option::Option::Some(PipelineStepStatus::PIPELINE_STEP_STATUS_FAILURE),
            3 => ::std::option::Option::Some(PipelineStepStatus::PIPELINE_STEP_STATUS_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PipelineStepStatus] = &[
        PipelineStepStatus::PIPELINE_STEP_STATUS_UNSET,
        PipelineStepStatus::PIPELINE_STEP_STATUS_SUCCESS,
        PipelineStepStatus::PIPELINE_STEP_STATUS_FAILURE,
        PipelineStepStatus::PIPELINE_STEP_STATUS_ERROR,
    ];
}

impl ::protobuf::EnumFull for PipelineStepStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PipelineStepStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PipelineStepStatus {
    fn default() -> Self {
        PipelineStepStatus::PIPELINE_STEP_STATUS_UNSET
    }
}

impl PipelineStepStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PipelineStepStatus>("PipelineStepStatus")
    }
}

///  A condition defines how the SDK should handle a step response -- should it
///  continue executing the pipeline, should it abort, should it notify the server?
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:protos.Condition)
pub enum Condition {
    // @@protoc_insertion_point(enum_value:protos.Condition.CONDITION_UNSET)
    CONDITION_UNSET = 0,
    // @@protoc_insertion_point(enum_value:protos.Condition.CONDITION_ON_ERROR_CONTINUE_PIPELINE)
    CONDITION_ON_ERROR_CONTINUE_PIPELINE = 1,
    // @@protoc_insertion_point(enum_value:protos.Condition.CONDITION_ON_ERROR_ABORT_PIPELINE)
    CONDITION_ON_ERROR_ABORT_PIPELINE = 2,
    // @@protoc_insertion_point(enum_value:protos.Condition.CONDITION_ON_ERROR_NOTIFY_SERVER)
    CONDITION_ON_ERROR_NOTIFY_SERVER = 3,
    // @@protoc_insertion_point(enum_value:protos.Condition.CONDITION_ON_MATCH_CONTINUE_PIPELINE)
    CONDITION_ON_MATCH_CONTINUE_PIPELINE = 4,
    // @@protoc_insertion_point(enum_value:protos.Condition.CONDITION_ON_MATCH_ABORT_PIPELINE)
    CONDITION_ON_MATCH_ABORT_PIPELINE = 5,
    // @@protoc_insertion_point(enum_value:protos.Condition.CONDITION_ON_MATCH_NOTIFY_SERVER)
    CONDITION_ON_MATCH_NOTIFY_SERVER = 6,
}

impl ::protobuf::Enum for Condition {
    const NAME: &'static str = "Condition";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Condition> {
        match value {
            0 => ::std::option::Option::Some(Condition::CONDITION_UNSET),
            1 => ::std::option::Option::Some(Condition::CONDITION_ON_ERROR_CONTINUE_PIPELINE),
            2 => ::std::option::Option::Some(Condition::CONDITION_ON_ERROR_ABORT_PIPELINE),
            3 => ::std::option::Option::Some(Condition::CONDITION_ON_ERROR_NOTIFY_SERVER),
            4 => ::std::option::Option::Some(Condition::CONDITION_ON_MATCH_CONTINUE_PIPELINE),
            5 => ::std::option::Option::Some(Condition::CONDITION_ON_MATCH_ABORT_PIPELINE),
            6 => ::std::option::Option::Some(Condition::CONDITION_ON_MATCH_NOTIFY_SERVER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Condition] = &[
        Condition::CONDITION_UNSET,
        Condition::CONDITION_ON_ERROR_CONTINUE_PIPELINE,
        Condition::CONDITION_ON_ERROR_ABORT_PIPELINE,
        Condition::CONDITION_ON_ERROR_NOTIFY_SERVER,
        Condition::CONDITION_ON_MATCH_CONTINUE_PIPELINE,
        Condition::CONDITION_ON_MATCH_ABORT_PIPELINE,
        Condition::CONDITION_ON_MATCH_NOTIFY_SERVER,
    ];
}

impl ::protobuf::EnumFull for Condition {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Condition").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Condition {
    fn default() -> Self {
        Condition::CONDITION_UNSET
    }
}

impl Condition {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Condition>("Condition")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0epipeline.proto\x12\x06protos\x1a\x15steps/detective.proto\x1a\x15s\
    teps/transform.proto\x1a\x12steps/encode.proto\x1a\x12steps/decode.proto\
    \x1a\x12steps/custom.proto\x1a\x0ccommon.proto\"\xfb\x03\n\x0cPipelineSt\
    ep\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x14\n\x05input\x18\x03\x20\x01(\x0cR\x05input\
    \x12\x17\n\x07wasm_id\x18\x04\x20\x01(\tR\x06wasmId\x12\x1d\n\nwasm_byte\
    s\x18\x05\x20\x01(\tR\twasmBytes\x12#\n\rwasm_function\x18\x06\x20\x01(\
    \tR\x0cwasmFunction\x121\n\nconditions\x18\x07\x20\x03(\x0e2\x11.protos.\
    ConditionR\nconditions\x12<\n\tdetective\x18\xe8\x07\x20\x01(\x0b2\x1b.p\
    rotos.steps.DetectiveStepH\0R\tdetective\x12<\n\ttransform\x18\xe9\x07\
    \x20\x01(\x0b2\x1b.protos.steps.TransformStepH\0R\ttransform\x123\n\x06e\
    ncode\x18\xea\x07\x20\x01(\x0b2\x18.protos.steps.EncodeStepH\0R\x06encod\
    e\x123\n\x06decode\x18\xeb\x07\x20\x01(\x0b2\x18.protos.steps.DecodeStep\
    H\0R\x06decode\x123\n\x06custom\x18\xec\x07\x20\x01(\x0b2\x18.protos.ste\
    ps.CustomStepH\0R\x06customB\x06\n\x04step\"\x89\x01\n\x14PipelineStepRe\
    sponse\x12\x16\n\x06output\x18\x01\x20\x01(\x0cR\x06output\x122\n\x06sta\
    tus\x18\x02\x20\x01(\x0e2\x1a.protos.PipelineStepStatusR\x06status\x12%\
    \n\x0estatus_message\x18\x03\x20\x01(\tR\rstatusMessage\"$\n\x12GetPipel\
    ineRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\x97\x01\n\x13GetP\
    ipelineResponse\x126\n\x08pipeline\x18\x01\x20\x01(\x0b2\x1a.protos.SetP\
    ipelineRequestR\x08pipeline\x12.\n\x06status\x18\x02\x20\x01(\x0e2\x16.p\
    rotos.ResponseStatusR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\tR\
    \x07message\"\x18\n\x16GetAllPipelinesRequest\"\x9d\x01\n\x17GetAllPipel\
    inesResponse\x128\n\tpipelines\x18\x01\x20\x03(\x0b2\x1a.protos.SetPipel\
    ineRequestR\tpipelines\x12.\n\x06status\x18\x02\x20\x01(\x0e2\x16.protos\
    .ResponseStatusR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07m\
    essage\"d\n\x12SetPipelineRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12*\n\x05steps\x18\
    \x03\x20\x03(\x0b2\x14.protos.PipelineStepR\x05steps\"o\n\x13SetPipeline\
    Response\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12.\n\x06status\x18\
    \x02\x20\x01(\x0e2\x16.protos.ResponseStatusR\x06status\x12\x18\n\x07mes\
    sage\x18\x03\x20\x01(\tR\x07message\"'\n\x15DeletePipelineRequest\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"r\n\x16DeletePipelineResponse\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12.\n\x06status\x18\x02\x20\
    \x01(\x0e2\x16.protos.ResponseStatusR\x06status\x12\x18\n\x07message\x18\
    \x03\x20\x01(\tR\x07message\"&\n\x14PausePipelineRequest\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\"q\n\x15PausePipelineResponse\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12.\n\x06status\x18\x02\x20\x01(\x0e2\x16.pr\
    otos.ResponseStatusR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\tR\
    \x07message\"(\n\x16UnpausePipelineRequest\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\"s\n\x17UnpausePipelineResponse\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12.\n\x06status\x18\x02\x20\x01(\x0e2\x16.protos.Res\
    ponseStatusR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07messa\
    ge*\x98\x01\n\x12PipelineStepStatus\x12\x1e\n\x1aPIPELINE_STEP_STATUS_UN\
    SET\x10\0\x12\x20\n\x1cPIPELINE_STEP_STATUS_SUCCESS\x10\x01\x12\x20\n\
    \x1cPIPELINE_STEP_STATUS_FAILURE\x10\x02\x12\x1e\n\x1aPIPELINE_STEP_STAT\
    US_ERROR\x10\x03*\x8e\x02\n\tCondition\x12\x13\n\x0fCONDITION_UNSET\x10\
    \0\x12(\n$CONDITION_ON_ERROR_CONTINUE_PIPELINE\x10\x01\x12%\n!CONDITION_\
    ON_ERROR_ABORT_PIPELINE\x10\x02\x12$\n\x20CONDITION_ON_ERROR_NOTIFY_SERV\
    ER\x10\x03\x12(\n$CONDITION_ON_MATCH_CONTINUE_PIPELINE\x10\x04\x12%\n!CO\
    NDITION_ON_MATCH_ABORT_PIPELINE\x10\x05\x12$\n\x20CONDITION_ON_MATCH_NOT\
    IFY_SERVER\x10\x06B4Z2github.com/streamdal/snitch-protos/build/go/protos\
    J\xc2%\n\x07\x12\x05\0\0\xa0\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\
    \x08\n\x01\x02\x12\x03\x02\0\x0f\n\t\n\x02\x03\0\x12\x03\x04\0\x1f\n\t\n\
    \x02\x03\x01\x12\x03\x05\0\x1f\n\t\n\x02\x03\x02\x12\x03\x06\0\x1c\n\t\n\
    \x02\x03\x03\x12\x03\x07\0\x1c\n\t\n\x02\x03\x04\x12\x03\x08\0\x1c\n\t\n\
    \x02\x03\x05\x12\x03\t\0\x16\n\x08\n\x01\x08\x12\x03\x0b\0I\n\t\n\x02\
    \x08\x0b\x12\x03\x0b\0I\n\x9d\x01\n\x02\x05\0\x12\x04\x0f\0\x14\x01\x1a\
    \x90\x01\x20Each\x20pipeline\x20step\x20includes\x20this\x20in\x20the\
    \x20response;\x20SDK\x20is\x20responsible\x20for\n\x20interpreting\x20th\
    e\x20response\x20status\x20and\x20apply\x20it\x20to\x20the\x20step\x20co\
    ndition.\n\n\n\n\x03\x05\0\x01\x12\x03\x0f\x05\x17\n\x0b\n\x04\x05\0\x02\
    \0\x12\x03\x10\x02!\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x10\x02\x1c\n\
    \x0c\n\x05\x05\0\x02\0\x02\x12\x03\x10\x1f\x20\n\x0b\n\x04\x05\0\x02\x01\
    \x12\x03\x11\x02#\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x11\x02\x1e\n\
    \x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x11!\"\n\x0b\n\x04\x05\0\x02\x02\
    \x12\x03\x12\x02#\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x12\x02\x1e\n\
    \x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x12!\"\n\x0b\n\x04\x05\0\x02\x03\
    \x12\x03\x13\x02!\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x13\x02\x1c\n\
    \x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x13\x1f\x20\n\xa9\x01\n\x02\x05\x01\
    \x12\x04\x18\0\"\x01\x1a\x9c\x01\x20A\x20condition\x20defines\x20how\x20\
    the\x20SDK\x20should\x20handle\x20a\x20step\x20response\x20--\x20should\
    \x20it\n\x20continue\x20executing\x20the\x20pipeline,\x20should\x20it\
    \x20abort,\x20should\x20it\x20notify\x20the\x20server?\n\n\n\n\x03\x05\
    \x01\x01\x12\x03\x18\x05\x0e\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x19\x02\
    \x16\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x19\x02\x11\n\x0c\n\x05\x05\
    \x01\x02\0\x02\x12\x03\x19\x14\x15\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\
    \x1a\x02+\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\x1a\x02&\n\x0c\n\x05\
    \x05\x01\x02\x01\x02\x12\x03\x1a)*\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\
    \x1b\x02(\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x1b\x02#\n\x0c\n\x05\
    \x05\x01\x02\x02\x02\x12\x03\x1b&'\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\
    \x1c\x02'\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x1c\x02\"\n\x0c\n\x05\
    \x05\x01\x02\x03\x02\x12\x03\x1c%&\n\x0b\n\x04\x05\x01\x02\x04\x12\x03\
    \x1d\x02+\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x1d\x02&\n\x0c\n\x05\
    \x05\x01\x02\x04\x02\x12\x03\x1d)*\n\x0b\n\x04\x05\x01\x02\x05\x12\x03\
    \x1e\x02(\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\x1e\x02#\n\x0c\n\x05\
    \x05\x01\x02\x05\x02\x12\x03\x1e&'\n\x0b\n\x04\x05\x01\x02\x06\x12\x03\
    \x1f\x02'\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03\x1f\x02\"\n\x0c\n\x05\
    \x05\x01\x02\x06\x02\x12\x03\x1f%&\n\n\n\x02\x04\0\x12\x04$\0B\x01\n\n\n\
    \x03\x04\0\x01\x12\x03$\x08\x14\n%\n\x04\x04\0\x02\0\x12\x03&\x02\x10\
    \x1a\x18\x20Unique\x20ID\x20for\x20the\x20step\n\n\x0c\n\x05\x04\0\x02\0\
    \x05\x12\x03&\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03&\t\x0b\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03&\x0e\x0f\n)\n\x04\x04\0\x02\x01\x12\x03)\
    \x02\x12\x1a\x1c\x20Friendly\x20name\x20for\x20the\x20step\n\n\x0c\n\x05\
    \x04\0\x02\x01\x05\x12\x03)\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\
    \x03)\t\r\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03)\x10\x11\nb\n\x04\x04\0\
    \x02\x02\x12\x03,\x02\x12\x1aU\x20Input\x20bytes\x20for\x20next\x20step\
    \x20(probably\x20PipelineStepResponse.output\x20from\x20previous\x20step\
    )\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03,\x02\x07\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03,\x08\r\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03,\x10\x11\n\
    \x1d\n\x04\x04\0\x02\x03\x12\x03/\x02\x15\x1a\x10\x20WASM\x20module\x20I\
    D\n\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03/\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03/\t\x10\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03/\x13\x14\n\
    \x20\n\x04\x04\0\x02\x04\x12\x032\x02\x18\x1a\x13\x20WASM\x20module\x20b\
    ytes\n\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x032\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x04\x01\x12\x032\t\x13\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x032\x16\
    \x17\n,\n\x04\x04\0\x02\x05\x12\x035\x02\x1b\x1a\x1f\x20WASM\x20function\
    \x20name\x20to\x20execute\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x035\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x035\t\x16\n\x0c\n\x05\x04\0\x02\
    \x05\x03\x12\x035\x19\x1a\nJ\n\x04\x04\0\x02\x06\x12\x038\x02$\x1a=\x20C\
    onditions\x20that\x20SDK\x20should\x20check\x20before\x20executing\x20ne\
    xt\x20step\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x038\x02\n\n\x0c\n\x05\
    \x04\0\x02\x06\x06\x12\x038\x0b\x14\n\x0c\n\x05\x04\0\x02\x06\x01\x12\
    \x038\x15\x1f\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x038\"#\nE\n\x04\x04\0\
    \x08\0\x12\x04;\x02A\x03\x1a7\x20All\x20steps\x20return\x20PipelineStepR\
    esponse\x20upon\x20completion\n\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03;\x08\
    \x0c\n\x0b\n\x04\x04\0\x02\x07\x12\x03<\x04)\n\x0c\n\x05\x04\0\x02\x07\
    \x06\x12\x03<\x04\x17\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03<\x18!\n\x0c\
    \n\x05\x04\0\x02\x07\x03\x12\x03<$(\n\x0b\n\x04\x04\0\x02\x08\x12\x03=\
    \x04)\n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03=\x04\x17\n\x0c\n\x05\x04\0\
    \x02\x08\x01\x12\x03=\x18!\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03=$(\n\
    \x0b\n\x04\x04\0\x02\t\x12\x03>\x04#\n\x0c\n\x05\x04\0\x02\t\x06\x12\x03\
    >\x04\x14\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03>\x15\x1b\n\x0c\n\x05\x04\0\
    \x02\t\x03\x12\x03>\x1e\"\n\x0b\n\x04\x04\0\x02\n\x12\x03?\x04#\n\x0c\n\
    \x05\x04\0\x02\n\x06\x12\x03?\x04\x14\n\x0c\n\x05\x04\0\x02\n\x01\x12\
    \x03?\x15\x1b\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03?\x1e\"\n\x0b\n\x04\x04\
    \0\x02\x0b\x12\x03@\x04#\n\x0c\n\x05\x04\0\x02\x0b\x06\x12\x03@\x04\x14\
    \n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03@\x15\x1b\n\x0c\n\x05\x04\0\x02\
    \x0b\x03\x12\x03@\x1e\"\n\x87\x01\n\x02\x04\x01\x12\x04F\0J\x01\x1a{\x20\
    All\x20WASM\x20funcs\x20return\x20this\x20upon\x20completion.\x20All\x20\
    WASM\x20funcs\x20MUST\x20include\x20`output`\n\x20(even\x20if\x20they\
    \x20do\x20not\x20modify\x20the\x20input).\n\n\n\n\x03\x04\x01\x01\x12\
    \x03F\x08\x1c\n\x0b\n\x04\x04\x01\x02\0\x12\x03G\x02\x13\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03G\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03G\
    \x08\x0e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03G\x11\x12\n\x0b\n\x04\x04\
    \x01\x02\x01\x12\x03H\x02\x20\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03H\
    \x02\x14\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03H\x15\x1b\n\x0c\n\x05\
    \x04\x01\x02\x01\x03\x12\x03H\x1e\x1f\n\x0b\n\x04\x04\x01\x02\x02\x12\
    \x03I\x02\x1c\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03I\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03I\t\x17\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03I\x1a\x1b\nM\n\x02\x04\x02\x12\x04N\0P\x012A********************\
    *\x20Get\x20(single)\x20pipeline\x20*********************\n\n\n\x03\x04\
    \x02\x01\x12\x03N\x08\x1a\n\x0b\n\x04\x04\x02\x02\0\x12\x03O\x02\x10\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03O\t\x0b\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03O\x0e\x0f\n\n\n\
    \x02\x04\x03\x12\x04R\0V\x01\n\n\n\x03\x04\x03\x01\x12\x03R\x08\x1b\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03S\x02\"\n\x0c\n\x05\x04\x03\x02\0\x06\
    \x12\x03S\x02\x14\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03S\x15\x1d\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x03S\x20!\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\
    T\x02\x1c\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03T\x02\x10\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03T\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\x03\
    \x12\x03T\x1a\x1b\n\x0b\n\x04\x04\x03\x02\x02\x12\x03U\x02\x15\n\x0c\n\
    \x05\x04\x03\x02\x02\x05\x12\x03U\x02\x08\n\x0c\n\x05\x04\x03\x02\x02\
    \x01\x12\x03U\t\x10\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03U\x13\x14\nH\
    \n\x02\x04\x04\x12\x03Z\0!2=*********************\x20Get\x20all\x20pipel\
    ines\x20*********************\n\n\n\x03\x04\x04\x01\x12\x03Z\x08\x1e\n\n\
    \n\x02\x04\x05\x12\x04\\\0`\x01\n\n\n\x03\x04\x05\x01\x12\x03\\\x08\x1f\
    \n\x0b\n\x04\x04\x05\x02\0\x12\x03]\x02,\n\x0c\n\x05\x04\x05\x02\0\x04\
    \x12\x03]\x02\n\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03]\x0b\x1d\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x03]\x1e'\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03]*+\n\x0b\n\x04\x04\x05\x02\x01\x12\x03^\x02\x1c\n\x0c\n\x05\x04\x05\
    \x02\x01\x06\x12\x03^\x02\x10\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03^\
    \x11\x17\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03^\x1a\x1b\n\x0b\n\x04\
    \x04\x05\x02\x02\x12\x03_\x02\x15\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\
    \x03_\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03_\t\x10\n\x0c\n\x05\
    \x04\x05\x02\x02\x03\x12\x03_\x13\x14\no\n\x02\x04\x06\x12\x04e\0n\x01\
    \x1a\x1e\x20Used\x20for\x20both\x20Add\x20and\x20Update\n2C*************\
    ********\x20Add/Set/Update\x20pipeline\x20*********************\n\n\n\
    \x03\x04\x06\x01\x12\x03e\x08\x1a\n)\n\x04\x04\x06\x02\0\x12\x03g\x02\
    \x10\x1a\x1c\x20Unique\x20ID\x20for\x20the\x20pipeline\n\n\x0c\n\x05\x04\
    \x06\x02\0\x05\x12\x03g\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03g\t\
    \x0b\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03g\x0e\x0f\n-\n\x04\x04\x06\x02\
    \x01\x12\x03j\x02\x12\x1a\x20\x20Friendly\x20name\x20for\x20the\x20pipel\
    ine\n\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03j\x02\x08\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03j\t\r\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03j\
    \x10\x11\n+\n\x04\x04\x06\x02\x02\x12\x03m\x02\"\x1a\x1e\x20One\x20or\
    \x20more\x20steps\x20to\x20execute\n\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\
    \x03m\x02\n\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03m\x0b\x17\n\x0c\n\x05\
    \x04\x06\x02\x02\x01\x12\x03m\x18\x1d\n\x0c\n\x05\x04\x06\x02\x02\x03\
    \x12\x03m\x20!\n\n\n\x02\x04\x07\x12\x04p\0y\x01\n\n\n\x03\x04\x07\x01\
    \x12\x03p\x08\x1b\n)\n\x04\x04\x07\x02\0\x12\x03r\x02\x10\x1a\x1c\x20Uni\
    que\x20ID\x20for\x20the\x20pipeline\n\n\x0c\n\x05\x04\x07\x02\0\x05\x12\
    \x03r\x02\x08\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03r\t\x0b\n\x0c\n\x05\
    \x04\x07\x02\0\x03\x12\x03r\x0e\x0f\nS\n\x04\x04\x07\x02\x01\x12\x03u\
    \x02\x1c\x1aF\x20Response\x20status\x20code;\x20use\x20for\x20identifyin\
    g\x20request\x20success\x20or\x20failure\n\n\x0c\n\x05\x04\x07\x02\x01\
    \x06\x12\x03u\x02\x10\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03u\x11\x17\n\
    \x0c\n\x05\x04\x07\x02\x01\x03\x12\x03u\x1a\x1b\n?\n\x04\x04\x07\x02\x02\
    \x12\x03x\x02\x15\x1a2\x20Additional\x20information\x20regarding\x20resp\
    onse\x20status\n\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03x\x02\x08\n\x0c\
    \n\x05\x04\x07\x02\x02\x01\x12\x03x\t\x10\n\x0c\n\x05\x04\x07\x02\x02\
    \x03\x12\x03x\x13\x14\nG\n\x02\x04\x08\x12\x05}\0\x80\x01\x012:*********\
    ************\x20Delete\x20pipeline\x20********************\n\n\n\x03\x04\
    \x08\x01\x12\x03}\x08\x1d\n)\n\x04\x04\x08\x02\0\x12\x03\x7f\x02\x10\x1a\
    \x1c\x20Unique\x20ID\x20for\x20the\x20pipeline\n\n\x0c\n\x05\x04\x08\x02\
    \0\x05\x12\x03\x7f\x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03\x7f\t\
    \x0b\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03\x7f\x0e\x0f\n\x0c\n\x02\x04\t\
    \x12\x06\x82\x01\0\x86\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x82\x01\x08\
    \x1e\n\x0c\n\x04\x04\t\x02\0\x12\x04\x83\x01\x02\x10\n\r\n\x05\x04\t\x02\
    \0\x05\x12\x04\x83\x01\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x83\x01\
    \t\x0b\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x83\x01\x0e\x0f\n\x0c\n\x04\x04\
    \t\x02\x01\x12\x04\x84\x01\x02\x1c\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\
    \x84\x01\x02\x10\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x84\x01\x11\x17\n\r\
    \n\x05\x04\t\x02\x01\x03\x12\x04\x84\x01\x1a\x1b\n\x0c\n\x04\x04\t\x02\
    \x02\x12\x04\x85\x01\x02\x15\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\x85\x01\
    \x02\x08\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\x85\x01\t\x10\n\r\n\x05\x04\
    \t\x02\x02\x03\x12\x04\x85\x01\x13\x14\nH\n\x02\x04\n\x12\x06\x8a\x01\0\
    \x8d\x01\x012:*********************\x20Pause\x20pipeline\x20************\
    *********\n\x0b\n\x03\x04\n\x01\x12\x04\x8a\x01\x08\x1c\n*\n\x04\x04\n\
    \x02\0\x12\x04\x8c\x01\x02\x10\x1a\x1c\x20Unique\x20ID\x20for\x20the\x20\
    pipeline\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x8c\x01\x02\x08\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\x8c\x01\t\x0b\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \x8c\x01\x0e\x0f\n\x0c\n\x02\x04\x0b\x12\x06\x8f\x01\0\x93\x01\x01\n\x0b\
    \n\x03\x04\x0b\x01\x12\x04\x8f\x01\x08\x1d\n\x0c\n\x04\x04\x0b\x02\0\x12\
    \x04\x90\x01\x02\x10\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x90\x01\x02\x08\
    \n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x90\x01\t\x0b\n\r\n\x05\x04\x0b\x02\
    \0\x03\x12\x04\x90\x01\x0e\x0f\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x91\
    \x01\x02\x1c\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\x91\x01\x02\x10\n\r\n\
    \x05\x04\x0b\x02\x01\x01\x12\x04\x91\x01\x11\x17\n\r\n\x05\x04\x0b\x02\
    \x01\x03\x12\x04\x91\x01\x1a\x1b\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\x92\
    \x01\x02\x15\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x92\x01\x02\x08\n\r\n\
    \x05\x04\x0b\x02\x02\x01\x12\x04\x92\x01\t\x10\n\r\n\x05\x04\x0b\x02\x02\
    \x03\x12\x04\x92\x01\x13\x14\nJ\n\x02\x04\x0c\x12\x06\x97\x01\0\x9a\x01\
    \x012<*********************\x20Unpause\x20pipeline\x20******************\
    ***\n\x0b\n\x03\x04\x0c\x01\x12\x04\x97\x01\x08\x1e\n*\n\x04\x04\x0c\x02\
    \0\x12\x04\x99\x01\x02\x10\x1a\x1c\x20Unique\x20ID\x20for\x20the\x20pipe\
    line\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x99\x01\x02\x08\n\r\n\x05\x04\
    \x0c\x02\0\x01\x12\x04\x99\x01\t\x0b\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\
    \x99\x01\x0e\x0f\n\x0c\n\x02\x04\r\x12\x06\x9c\x01\0\xa0\x01\x01\n\x0b\n\
    \x03\x04\r\x01\x12\x04\x9c\x01\x08\x1f\n\x0c\n\x04\x04\r\x02\0\x12\x04\
    \x9d\x01\x02\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x9d\x01\x02\x08\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\x9d\x01\t\x0b\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\x9d\x01\x0e\x0f\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x9e\x01\x02\x1c\n\
    \r\n\x05\x04\r\x02\x01\x06\x12\x04\x9e\x01\x02\x10\n\r\n\x05\x04\r\x02\
    \x01\x01\x12\x04\x9e\x01\x11\x17\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x9e\
    \x01\x1a\x1b\n\x0c\n\x04\x04\r\x02\x02\x12\x04\x9f\x01\x02\x15\n\r\n\x05\
    \x04\r\x02\x02\x05\x12\x04\x9f\x01\x02\x08\n\r\n\x05\x04\r\x02\x02\x01\
    \x12\x04\x9f\x01\t\x10\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x9f\x01\x13\
    \x14b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(super::detective::file_descriptor().clone());
            deps.push(super::transform::file_descriptor().clone());
            deps.push(super::encode::file_descriptor().clone());
            deps.push(super::decode::file_descriptor().clone());
            deps.push(super::custom::file_descriptor().clone());
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(14);
            messages.push(PipelineStep::generated_message_descriptor_data());
            messages.push(PipelineStepResponse::generated_message_descriptor_data());
            messages.push(GetPipelineRequest::generated_message_descriptor_data());
            messages.push(GetPipelineResponse::generated_message_descriptor_data());
            messages.push(GetAllPipelinesRequest::generated_message_descriptor_data());
            messages.push(GetAllPipelinesResponse::generated_message_descriptor_data());
            messages.push(SetPipelineRequest::generated_message_descriptor_data());
            messages.push(SetPipelineResponse::generated_message_descriptor_data());
            messages.push(DeletePipelineRequest::generated_message_descriptor_data());
            messages.push(DeletePipelineResponse::generated_message_descriptor_data());
            messages.push(PausePipelineRequest::generated_message_descriptor_data());
            messages.push(PausePipelineResponse::generated_message_descriptor_data());
            messages.push(UnpausePipelineRequest::generated_message_descriptor_data());
            messages.push(UnpausePipelineResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(PipelineStepStatus::generated_enum_descriptor_data());
            enums.push(Condition::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
