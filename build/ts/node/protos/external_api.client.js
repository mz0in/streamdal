// @generated by protobuf-ts 2.9.0 with parameter optimize_code_size
// @generated from protobuf file "external_api.proto" (package "protos", syntax proto3)
// tslint:disable
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { External } from "./external_api";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service protos.External
 */ export var ExternalClient = /*#__PURE__*/ function() {
    "use strict";
    function ExternalClient(_transport) {
        _class_call_check(this, ExternalClient);
        _define_property(this, "_transport", void 0);
        _define_property(this, "typeName", void 0);
        _define_property(this, "methods", void 0);
        _define_property(this, "options", void 0);
        this._transport = _transport;
        this.typeName = External.typeName;
        this.methods = External.methods;
        this.options = External.options;
    }
    _create_class(ExternalClient, [
        {
            /**
     * Build a service map
     *
     * @generated from protobuf rpc: GetServices(protos.GetServicesRequest) returns (protos.GetServicesResponse);
     */ key: "getServices",
            value: function getServices(input, options) {
                var method = this.methods[0], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Figure out consumers/producers, pipelines and targets for a given service
     *
     * @generated from protobuf rpc: GetService(protos.GetServiceRequest) returns (protos.GetServiceResponse);
     */ key: "getService",
            value: function getService(input, options) {
                var method = this.methods[1], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Get all available pipelines
     *
     * @generated from protobuf rpc: GetPipelines(protos.GetPipelinesRequest) returns (protos.GetPipelinesResponse);
     */ key: "getPipelines",
            value: function getPipelines(input, options) {
                var method = this.methods[2], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Get a pipeline (and its steps)
     *
     * @generated from protobuf rpc: GetPipeline(protos.GetPipelineRequest) returns (protos.GetPipelineResponse);
     */ key: "getPipeline",
            value: function getPipeline(input, options) {
                var method = this.methods[3], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Associate steps with a pipeline // Can also use this to set steps in one big push
     *
     * @generated from protobuf rpc: SetPipeline(protos.SetPipelineRequest) returns (protos.SetPipelineResponse);
     */ key: "setPipeline",
            value: function setPipeline(input, options) {
                var method = this.methods[4], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Delete a pipeline
     *
     * @generated from protobuf rpc: DeletePipeline(protos.DeletePipelineRequest) returns (protos.DeletePipelineResponse);
     */ key: "deletePipeline",
            value: function deletePipeline(input, options) {
                var method = this.methods[5], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Get steps associated with a pipeline
     *
     * @generated from protobuf rpc: GetSteps(protos.GetStepsRequest) returns (protos.GetStepsResponse);
     */ key: "getSteps",
            value: function getSteps(input, options) {
                var method = this.methods[6], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Create a step
     *
     * @generated from protobuf rpc: CreateStep(protos.CreateStepRequest) returns (protos.CreateStepResponse);
     */ key: "createStep",
            value: function createStep(input, options) {
                var method = this.methods[7], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Update a step
     *
     * @generated from protobuf rpc: UpdateStep(protos.UpdateStepRequest) returns (protos.UpdateStepResponse);
     */ key: "updateStep",
            value: function updateStep(input, options) {
                var method = this.methods[8], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Delete a step
     *
     * @generated from protobuf rpc: DeleteStep(protos.DeleteStepRequest) returns (protos.DeleteStepResponse);
     */ key: "deleteStep",
            value: function deleteStep(input, options) {
                var method = this.methods[9], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        },
        {
            /**
     * Test method
     *
     * @generated from protobuf rpc: Test(protos.TestRequest) returns (protos.TestResponse);
     */ key: "test",
            value: function test(input, options) {
                var method = this.methods[10], opt = this._transport.mergeOptions(options);
                return stackIntercept("unary", this._transport, method, opt, input);
            }
        }
    ]);
    return ExternalClient;
}();
