# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: common.proto, external_api.proto, pipeline.proto, internal_api.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncGenerator, Dict, List, Optional

import betterproto
import grpclib

from .protos import steps


class ResponseCode(betterproto.Enum):
    """Common status codes used in gRPC method responses"""

    RESPONSE_CODE_UNSET = 0
    RESPONSE_CODE_OK = 1
    RESPONSE_CODE_BAD_REQUEST = 2
    RESPONSE_CODE_NOT_FOUND = 3
    RESPONSE_CODE_INTERNAL_SERVER_ERROR = 4
    RESPONSE_CODE_GENERIC_ERROR = 5


class WASMExitCode(betterproto.Enum):
    """
    Included in WASM response; SDK is responsible for interpreting the response
    status and how it relates to the step condition. ie. WASM func returns
    WASM_EXIT_CODE_INTERNAL_ERROR lookup ON_ERROR conditions to determine what
    to do next. ie. WASM func returns WASM_EXIT_CODE_SUCCESS lookup ON_MATCH
    conditions to determine what to do next;
    """

    WASM_EXIT_CODE_UNSET = 0
    WASM_EXIT_CODE_SUCCESS = 1
    WASM_EXIT_CODE_FAILURE = 2
    WASM_EXIT_CODE_INTERNAL_ERROR = 3


class PipelineStepCondition(betterproto.Enum):
    """
    A condition defines how the SDK should handle a step response -- should it
    continue executing the pipeline, should it abort, should it notify the
    server? Each step can have multiple conditions.
    """

    CONDITION_UNSET = 0
    CONDITION_CONTINUE = 1
    CONDITION_ABORT = 2
    CONDITION_NOTIFY = 3


class CommandType(betterproto.Enum):
    """Types of commands that can be sent to the SDK"""

    SNITCH_COMMAND_TYPE_UNSET = 0
    SNITCH_COMMAND_TYPE_KEEPALIVE = 1
    SNITCH_COMMAND_TYPE_SET_PIPELINE = 2
    SNITCH_COMMAND_TYPE_DELETE_PIPELINE = 3
    SNITCH_COMMAND_TYPE_PAUSE_PIPELINE = 4
    SNITCH_COMMAND_TYPE_UNPAUSE_PIPELINE = 5


class OperationType(betterproto.Enum):
    OPERATION_TYPE_UNSET = 0
    OPERATION_TYPE_CONSUMER = 1
    OPERATION_TYPE_PRODUCER = 2


@dataclass
class StandardResponse(betterproto.Message):
    """Common response message for many gRPC methods"""

    # Co-relation ID for the request / response
    id: str = betterproto.string_field(1)
    code: "ResponseCode" = betterproto.enum_field(2)
    message: str = betterproto.string_field(3)
    # Debug info that server may populate with additional info.
    _metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class GetServicesRequest(betterproto.Message):
    """protolint:disable INDENT"""

    pass


@dataclass
class GetServicesResponse(betterproto.Message):
    pass


@dataclass
class GetServiceRequest(betterproto.Message):
    pass


@dataclass
class GetServiceResponse(betterproto.Message):
    pass


@dataclass
class GetPipelinesRequest(betterproto.Message):
    pass


@dataclass
class GetPipelinesResponse(betterproto.Message):
    pass


@dataclass
class GetPipelineRequest(betterproto.Message):
    pass


@dataclass
class GetPipelineResponse(betterproto.Message):
    pass


@dataclass
class SetPipelineRequest(betterproto.Message):
    pass


@dataclass
class SetPipelineResponse(betterproto.Message):
    pass


@dataclass
class DeletePipelineRequest(betterproto.Message):
    pass


@dataclass
class DeletePipelineResponse(betterproto.Message):
    pass


@dataclass
class GetStepsRequest(betterproto.Message):
    pass


@dataclass
class GetStepsResponse(betterproto.Message):
    pass


@dataclass
class CreateStepRequest(betterproto.Message):
    pass


@dataclass
class CreateStepResponse(betterproto.Message):
    pass


@dataclass
class UpdateStepRequest(betterproto.Message):
    pass


@dataclass
class UpdateStepResponse(betterproto.Message):
    pass


@dataclass
class DeleteStepRequest(betterproto.Message):
    pass


@dataclass
class DeleteStepResponse(betterproto.Message):
    pass


@dataclass
class TestRequest(betterproto.Message):
    input: str = betterproto.string_field(1)


@dataclass
class TestResponse(betterproto.Message):
    output: str = betterproto.string_field(2)


@dataclass
class WASMRequest(betterproto.Message):
    """SDK generates a WASM request and passes this to the WASM func"""

    step: "PipelineStep" = betterproto.message_field(1)
    input: bytes = betterproto.bytes_field(2)


@dataclass
class WASMResponse(betterproto.Message):
    """Returned by all WASM functions"""

    output: bytes = betterproto.bytes_field(1)
    exit_code: "WASMExitCode" = betterproto.enum_field(2)
    exit_msg: str = betterproto.string_field(3)


@dataclass
class PipelineStep(betterproto.Message):
    """
    A PipelineCommand consists of one or more pipeline steps. A pipeline step
    is an immutable set of instructions on how to execute a step. The SDK will
    use the pipeline step to generate a WASM request.
    """

    # Unique ID for the step
    id: str = betterproto.string_field(1)
    # Friendly name for the step
    name: str = betterproto.string_field(2)
    # Conditions that SDK should check before executing next step
    conditions: List["PipelineStepCondition"] = betterproto.enum_field(3)
    detective: steps.DetectiveStep = betterproto.message_field(1000, group="step")
    transform: steps.TransformStep = betterproto.message_field(1001, group="step")
    encode: steps.EncodeStep = betterproto.message_field(1002, group="step")
    decode: steps.DecodeStep = betterproto.message_field(1003, group="step")
    custom: steps.CustomStep = betterproto.message_field(1004, group="step")
    # WASM module ID (set by backend)
    _wasm_id: str = betterproto.string_field(10000)
    # WASM module bytes (set by backend)
    _wasm_bytes: bytes = betterproto.bytes_field(10001)
    # WASM function name to execute (set by backend)
    _wasm_function: str = betterproto.string_field(10002)


@dataclass
class SetPipelineCommand(betterproto.Message):
    """Used for both Add and Update"""

    # Unique ID for the pipeline
    id: str = betterproto.string_field(1)
    # Friendly name for the pipeline
    name: str = betterproto.string_field(2)
    # One or more steps to execute
    steps: List["PipelineStep"] = betterproto.message_field(3)


@dataclass
class DeletePipelineCommand(betterproto.Message):
    # Unique ID for the pipeline
    id: str = betterproto.string_field(1)


@dataclass
class PausePipelineCommand(betterproto.Message):
    # Unique ID for the pipeline
    id: str = betterproto.string_field(1)


@dataclass
class UnpausePipelineCommand(betterproto.Message):
    # Unique ID for the pipeline
    id: str = betterproto.string_field(1)


@dataclass
class HeartbeatRequest(betterproto.Message):
    """
    Each consumer and producer should send periodic heartbeats to the server to
    let the server know that they are still active.
    """

    audience: "Audience" = betterproto.message_field(1)
    last_activity_unix_timestamp_utc: int = betterproto.int64_field(2)
    _metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class NotifyRequest(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    rule_name: str = betterproto.string_field(2)
    audience: "Audience" = betterproto.message_field(3)
    occurred_at_unix_ts_utc: int = betterproto.int64_field(4)
    _metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class MetricsRequest(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    rule_name: str = betterproto.string_field(2)
    audience: "Audience" = betterproto.message_field(3)
    _metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class RegisterRequest(betterproto.Message):
    service_name: str = betterproto.string_field(1)
    # If set, we know that any pipelines or steps executed in this SDK will NOT
    # modify the input/output data. As in, the SDK will log what it _would_ do
    # and always return the original data set.
    dry_run: bool = betterproto.bool_field(2)
    # snitch-server uses this under the hood for debug
    _metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class BusEvent(betterproto.Message):
    """Type used by `snitch-server` for sending messages on its local bus."""

    request_id: str = betterproto.string_field(1)
    source: str = betterproto.string_field(2)
    command_response: "CommandResponse" = betterproto.message_field(100, group="event")
    register_request: "RegisterRequest" = betterproto.message_field(101, group="event")
    _metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class CommandResponse(betterproto.Message):
    """
    The primary method to send commands to the SDK; server will send zero or
    more RegisterResponse's with SetPipelineRequest on SDK instantiation.
    """

    # Who is this command intended for?
    audience: "Audience" = betterproto.message_field(1)
    set_pipeline: "SetPipelineCommand" = betterproto.message_field(100, group="command")
    delete_pipeline: "DeletePipelineCommand" = betterproto.message_field(
        101, group="command"
    )
    pause_pipeline: "PausePipelineCommand" = betterproto.message_field(
        102, group="command"
    )
    unpause_pipeline: "UnpausePipelineCommand" = betterproto.message_field(
        103, group="command"
    )
    _metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class Audience(betterproto.Message):
    """Used to indicate who a request/command is intended for"""

    # Name of the service
    service_name: str = betterproto.string_field(1)
    # Name of the component the SDK is interacting with (ie. kafka-$topic-name)
    component_name: str = betterproto.string_field(2)
    # Consumer or Producer
    operation_type: "OperationType" = betterproto.enum_field(3)


class ExternalStub(betterproto.ServiceStub):
    async def get_services(self) -> GetServicesResponse:
        """Build a service map"""

        request = GetServicesRequest()

        return await self._unary_unary(
            "/protos.External/GetServices",
            request,
            GetServicesResponse,
        )

    async def get_service(self) -> GetServiceResponse:
        """
        Figure out consumers/producers, pipelines and targets for a given
        service
        """

        request = GetServiceRequest()

        return await self._unary_unary(
            "/protos.External/GetService",
            request,
            GetServiceResponse,
        )

    async def get_pipelines(self) -> GetPipelinesResponse:
        """Get all available pipelines"""

        request = GetPipelinesRequest()

        return await self._unary_unary(
            "/protos.External/GetPipelines",
            request,
            GetPipelinesResponse,
        )

    async def get_pipeline(self) -> GetPipelineResponse:
        """Get a pipeline (and its steps)"""

        request = GetPipelineRequest()

        return await self._unary_unary(
            "/protos.External/GetPipeline",
            request,
            GetPipelineResponse,
        )

    async def set_pipeline(self) -> SetPipelineResponse:
        """
        Associate steps with a pipeline // Can also use this to set steps in
        one big push
        """

        request = SetPipelineRequest()

        return await self._unary_unary(
            "/protos.External/SetPipeline",
            request,
            SetPipelineResponse,
        )

    async def delete_pipeline(self) -> DeletePipelineResponse:
        """Delete a pipeline"""

        request = DeletePipelineRequest()

        return await self._unary_unary(
            "/protos.External/DeletePipeline",
            request,
            DeletePipelineResponse,
        )

    async def get_steps(self) -> GetStepsResponse:
        """Get steps associated with a pipeline"""

        request = GetStepsRequest()

        return await self._unary_unary(
            "/protos.External/GetSteps",
            request,
            GetStepsResponse,
        )

    async def create_step(self) -> CreateStepResponse:
        """Create a step"""

        request = CreateStepRequest()

        return await self._unary_unary(
            "/protos.External/CreateStep",
            request,
            CreateStepResponse,
        )

    async def update_step(self) -> UpdateStepResponse:
        """Update a step"""

        request = UpdateStepRequest()

        return await self._unary_unary(
            "/protos.External/UpdateStep",
            request,
            UpdateStepResponse,
        )

    async def delete_step(self) -> DeleteStepResponse:
        """Delete a step"""

        request = DeleteStepRequest()

        return await self._unary_unary(
            "/protos.External/DeleteStep",
            request,
            DeleteStepResponse,
        )

    async def test(self, *, input: str = "") -> TestResponse:
        """Test method"""

        request = TestRequest()
        request.input = input

        return await self._unary_unary(
            "/protos.External/Test",
            request,
            TestResponse,
        )


class InternalStub(betterproto.ServiceStub):
    async def register(
        self,
        *,
        service_name: str = "",
        dry_run: bool = False,
        _metadata: Optional[Dict[str, str]] = None,
    ) -> AsyncGenerator[CommandResponse, None]:
        """
        Initial method that an SDK should call to register itself with the
        server. The server will use this stream to send commands to the SDK via
        the `CommandResponse` message. Clients should continuously listen for
        CommandResponse messages and re-establish registration if the stream
        gets disconnected.
        """

        request = RegisterRequest()
        request.service_name = service_name
        request.dry_run = dry_run
        request._metadata = _metadata

        async for response in self._unary_stream(
            "/protos.Internal/Register",
            request,
            CommandResponse,
        ):
            yield response

    async def heartbeat(
        self,
        *,
        audience: Optional["Audience"] = None,
        last_activity_unix_timestamp_utc: int = 0,
        _metadata: Optional[Dict[str, str]] = None,
    ) -> StandardResponse:
        """
        SDK is responsible for sending heartbeats to the server to let the
        server know about active consumers and producers.
        """

        request = HeartbeatRequest()
        if audience is not None:
            request.audience = audience
        request.last_activity_unix_timestamp_utc = last_activity_unix_timestamp_utc
        request._metadata = _metadata

        return await self._unary_unary(
            "/protos.Internal/Heartbeat",
            request,
            StandardResponse,
        )

    async def notify(
        self,
        *,
        rule_id: str = "",
        rule_name: str = "",
        audience: Optional["Audience"] = None,
        occurred_at_unix_ts_utc: int = 0,
        _metadata: Optional[Dict[str, str]] = None,
    ) -> StandardResponse:
        """
        Use this method when Notify condition has been triggered; the server
        will decide on what to do about the notification.
        """

        request = NotifyRequest()
        request.rule_id = rule_id
        request.rule_name = rule_name
        if audience is not None:
            request.audience = audience
        request.occurred_at_unix_ts_utc = occurred_at_unix_ts_utc
        request._metadata = _metadata

        return await self._unary_unary(
            "/protos.Internal/Notify",
            request,
            StandardResponse,
        )

    async def metrics(
        self,
        *,
        rule_id: str = "",
        rule_name: str = "",
        audience: Optional["Audience"] = None,
        _metadata: Optional[Dict[str, str]] = None,
    ) -> StandardResponse:
        """Send periodic metrics to the server"""

        request = MetricsRequest()
        request.rule_id = rule_id
        request.rule_name = rule_name
        if audience is not None:
            request.audience = audience
        request._metadata = _metadata

        return await self._unary_unary(
            "/protos.Internal/Metrics",
            request,
            StandardResponse,
        )
