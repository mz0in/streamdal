"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nextCharOffsetFactory = exports.prevCharOffsetFactory = exports.normalizePosition = exports.getPositionAtFactory = exports.requirePkg = exports.loadModule = exports.loadEsmModule = exports.getPhysicalFilename = exports.arrayify = exports.last = void 0;
const tslib_1 = require("tslib");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const node_url_1 = require("node:url");
const last = (items) => items && items[items.length - 1];
exports.last = last;
const arrayify = (...args) => args.reduce((arr, curr) => {
    arr.push(...(Array.isArray(curr) ? curr : curr == null ? [] : [curr]));
    return arr;
}, []);
exports.arrayify = arrayify;
const getPhysicalFilename = (filename, child) => {
    try {
        if (node_fs_1.default.statSync(filename).isDirectory()) {
            return child || filename;
        }
    }
    catch (err) {
        const { code } = err;
        if (code === 'ENOTDIR' || code === 'ENOENT') {
            return (0, exports.getPhysicalFilename)(node_path_1.default.dirname(filename), filename);
        }
    }
    return filename;
};
exports.getPhysicalFilename = getPhysicalFilename;
const loadEsmModule = (modulePath) => new Function('modulePath', `return import(modulePath);`)(modulePath);
exports.loadEsmModule = loadEsmModule;
const loadModule = (modulePath) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const esModulePath = node_path_1.default.isAbsolute(modulePath)
        ? (0, node_url_1.pathToFileURL)(modulePath)
        : modulePath;
    switch (node_path_1.default.extname(modulePath)) {
        case '.mjs': {
            return (yield (0, exports.loadEsmModule)(esModulePath)).default;
        }
        case '.cjs': {
            return require(modulePath);
        }
        default: {
            try {
                return require(modulePath);
            }
            catch (err) {
                const code = err.code;
                if (code === 'ERR_REQUIRE_ESM' ||
                    code === 'ERR_PACKAGE_PATH_NOT_EXPORTED') {
                    return (yield (0, exports.loadEsmModule)(esModulePath)).default;
                }
                throw err;
            }
        }
    }
});
exports.loadModule = loadModule;
const requirePkg = (plugin, prefix, filePath) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let packages;
    if (filePath && /^\.\.?(?:[/\\]|$)/.test(plugin)) {
        packages = [node_path_1.default.resolve(node_path_1.default.dirname(filePath), plugin)];
    }
    else {
        prefix = prefix.endsWith('-') ? prefix : prefix + '-';
        packages = [
            plugin,
            plugin.startsWith('@')
                ? plugin.replace('/', '/' + prefix)
                : prefix + plugin,
        ];
    }
    let error;
    for (const pkg of packages) {
        try {
            return yield (0, exports.loadModule)(pkg);
        }
        catch (err) {
            if (!error) {
                error = err;
            }
        }
    }
    throw error;
});
exports.requirePkg = requirePkg;
const getPositionAtFactory = (text) => {
    const lines = text.split('\n');
    return (offset) => {
        let currOffset = 0;
        for (const [index, line_] of lines.entries()) {
            const line = index + 1;
            const nextOffset = currOffset + line_.length;
            if (nextOffset >= offset) {
                return {
                    line,
                    column: offset - currOffset,
                    offset,
                };
            }
            currOffset = nextOffset + 1;
        }
    };
};
exports.getPositionAtFactory = getPositionAtFactory;
const normalizePosition = ({ start, end, text, }) => {
    const startOffset = start.offset;
    const endOffset = end.offset;
    const range = [startOffset, endOffset];
    const getPositionAt = text == null
        ? null
        : (0, exports.getPositionAtFactory)(text);
    return {
        start: startOffset,
        end: endOffset,
        loc: {
            start: 'line' in start
                ? start
                : getPositionAt(startOffset),
            end: 'line' in end
                ? end
                : getPositionAt(endOffset),
        },
        range,
    };
};
exports.normalizePosition = normalizePosition;
const prevCharOffsetFactory = (text) => (offset) => {
    for (let i = offset; i >= 0; i--) {
        const char = text[i];
        if (/^\S$/.test(char)) {
            return i;
        }
    }
};
exports.prevCharOffsetFactory = prevCharOffsetFactory;
const nextCharOffsetFactory = (text) => {
    const total = text.length;
    return (offset) => {
        for (let i = offset; i <= total; i++) {
            const char = text[i];
            if (/^\S$/.test(char)) {
                return i;
            }
        }
    };
};
exports.nextCharOffsetFactory = nextCharOffsetFactory;
//# sourceMappingURL=helpers.js.map